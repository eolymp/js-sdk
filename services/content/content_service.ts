// Generated by the protocol buffer compiler. DO NOT EDIT!
// See https://github.com/eolymp/contracts/tree/main/cmd/protoc-gen-js-esdk for more details.

import { ExpressionEnum, ExpressionID, ExpressionString } from "../wellknown/expression"
import { Fragment, Fragment_Translation } from "./content_fragment"

interface Client {
  call<R, E, O>(verb: string, url: string, args: R, opts?: any): Promise<E>;
}

export class ContentService {
  private readonly cli: Client;
  private readonly url: string;

  constructor(cli: Client, url: string = 'https://api.eolymp.com') {
    this.cli = cli;
    this.url = url;
  }

  DescribeFragment(input: DescribeFragmentInput, opts?: any): Promise<DescribeFragmentOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'');

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);

    return this.cli.call("GET", this.url+path, input, opts);
  }

  ListFragments(input: ListFragmentsInput, opts?: any): Promise<ListFragmentsOutput> {
    const path = "/content/fragments";

    return this.cli.call("GET", this.url+path, input, opts);
  }

  CreateFragment(input: CreateFragmentInput, opts?: any): Promise<CreateFragmentOutput> {
    const path = "/content/fragments";

    return this.cli.call("POST", this.url+path, input, opts);
  }

  UpdateFragment(input: UpdateFragmentInput, opts?: any): Promise<UpdateFragmentOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'');

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);

    return this.cli.call("PUT", this.url+path, input, opts);
  }

  DeleteFragment(input: DeleteFragmentInput, opts?: any): Promise<DeleteFragmentOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'');

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);

    return this.cli.call("DELETE", this.url+path, input, opts);
  }

  TranslateFragment(input: TranslateFragmentInput, opts?: any): Promise<TranslateFragmentOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'')+"/translate";

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);

    return this.cli.call("POST", this.url+path, input, opts);
  }

  DescribeFragmentTranslation(input: DescribeFragmentTranslationInput, opts?: any): Promise<DescribeFragmentTranslationOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'')+"/translations/"+encodeURIComponent(input.translationId||'');

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);
    delete(input.translationId);

    return this.cli.call("GET", this.url+path, input, opts);
  }

  ListFragmentTranslations(input: ListFragmentTranslationsInput, opts?: any): Promise<ListFragmentTranslationsOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'')+"/translations";

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);

    return this.cli.call("GET", this.url+path, input, opts);
  }

  CreateFragmentTranslation(input: CreateFragmentTranslationInput, opts?: any): Promise<CreateFragmentTranslationOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'')+"/translations";

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);

    return this.cli.call("POST", this.url+path, input, opts);
  }

  UpdateFragmentTranslation(input: UpdateFragmentTranslationInput, opts?: any): Promise<UpdateFragmentTranslationOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'')+"/translations/"+encodeURIComponent(input.translationId||'');

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);
    delete(input.translationId);

    return this.cli.call("PUT", this.url+path, input, opts);
  }

  DeleteFragmentTranslation(input: DeleteFragmentTranslationInput, opts?: any): Promise<DeleteFragmentTranslationOutput> {
    const path = "/content/fragments/"+encodeURIComponent(input.fragmentId||'')+"/translations/"+encodeURIComponent(input.translationId||'');

    // Cleanup URL parameters to avoid any ambiguity
    delete(input.fragmentId);
    delete(input.translationId);

    return this.cli.call("DELETE", this.url+path, input, opts);
  }

  DescribePath(input: DescribePathInput, opts?: any): Promise<DescribePathOutput> {
    const path = "/content/path";

    return this.cli.call("GET", this.url+path, input, opts);
  }

  ListParents(input: ListParentsInput, opts?: any): Promise<ListParentsOutput> {
    const path = "/content/parents";

    return this.cli.call("GET", this.url+path, input, opts);
  }
}

export type FragmentChangedEvent = {
  scope?: string;
  before?: Fragment;
  after?: Fragment;
}

export type FragmentTranslationChangedEvent = {
  fragmentId?: string;
  before?: Fragment_Translation;
  after?: Fragment_Translation;
}

export type DescribeFragmentInput = {
  fragmentId?: string;
  extra?: string[];
}

export type DescribeFragmentOutput = {
  fragment?: Fragment;
}

export type ListFragmentsInput = {
  offset?: number;
  size?: number;
  filters?: ListFragmentsInput_Filter;
  sort?: string;
  order?: string;
  locale?: string;
  extra?: string[];
}

export type ListFragmentsInput_Filter = {
  query?: string;
  id?: ExpressionID[];
  path?: ExpressionString[];
  locale?: ExpressionEnum[];
  label?: ExpressionEnum[];
}

export type ListFragmentsOutput = {
  total?: number;
  items?: Fragment[];
}

export type CreateFragmentInput = {
  fragment?: Fragment;
}

export type CreateFragmentOutput = {
  fragmentId?: string;
}

export type UpdateFragmentInput = {
  patch?: string[];
  fragmentId?: string;
  fragment?: Fragment;
}

export type UpdateFragmentOutput = Record<string, unknown>;

export type DeleteFragmentInput = {
  fragmentId?: string;
}

export type DeleteFragmentOutput = Record<string, unknown>;

export type TranslateFragmentInput = {
  fragmentId?: string;
  source?: string;
  target?: string[];
  targetAutomatic?: boolean;
  overrideManual?: boolean;
}

export type TranslateFragmentOutput = {
  jobId?: string;
}

export type DescribeFragmentTranslationInput = {
  fragmentId?: string;
  translationId?: string;
  extra?: string[];
}

export type DescribeFragmentTranslationOutput = {
  translation?: Fragment_Translation;
}

export type ListFragmentTranslationsInput = {
  fragmentId?: string;
  offset?: number;
  size?: number;
  filters?: ListFragmentTranslationsInput_Filter;
  extra?: string[];
}

export type ListFragmentTranslationsInput_Filter = {
  query?: string;
  id?: ExpressionID[];
  locale?: ExpressionEnum[];
}

export type ListFragmentTranslationsOutput = {
  total?: number;
  items?: Fragment_Translation[];
}

export type CreateFragmentTranslationInput = {
  fragmentId?: string;
  translation?: Fragment_Translation;
}

export type CreateFragmentTranslationOutput = {
  translationId?: string;
}

export type UpdateFragmentTranslationInput = {
  fragmentId?: string;
  translationId?: string;
  translation?: Fragment_Translation;
}

export type UpdateFragmentTranslationOutput = Record<string, unknown>;

export type DeleteFragmentTranslationInput = {
  fragmentId?: string;
  translationId?: string;
}

export type DeleteFragmentTranslationOutput = Record<string, unknown>;

export type DescribePathInput = {
  path?: string;
  locale?: string;
  extra?: string[];
}

export type DescribePathOutput = {
  fragment?: Fragment;
}

export type ListParentsInput = {
  path?: string;
  locale?: string;
  extra?: string[];
}

export type ListParentsOutput = {
  total?: number;
  items?: Fragment[];
}

